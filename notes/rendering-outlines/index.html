<!-- Made by Alexander Ameye using pure html/css and eleventy ♥ -->
<!DOCTYPE html>
<html lang="en">
    <!-- HEAD -->
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<meta name="description" content="Different techniques for rendering outline effects.">
<meta name="author" content="Alexander Ameye">

<!-- Tells Google not to provide a translation for this document -->
<meta name="google" content="notranslate">

<!-- Identify the software used to build the document -->
<meta name="generator" content="eleventy">

<!-- Open graph -->
<meta property="og:title" content="5 ways to draw an outline">
<meta property="og:description" content="Different techniques for rendering outline effects.">
<meta property="og:type" content="article">
<meta property="og:image" content="https://alexanderameye.github.io/notes/undefined"/>
<meta property="og:image:width" content="1200"/>
<meta property="og:image:height" content="675"/>

<!-- Twitter -->
<meta name="twitter:title" content="5 ways to draw an outline">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@alexanderameye">
<meta name="twitter:description" content="Different techniques for rendering outline effects.">
<meta name="twitter:image" content="https://alexanderameye.github.io/notes/undefined">
<meta name="twitter:creator" content="@alexanderameye">

<title>5 ways to draw an outline</title>

<!-- CSS -->
<link rel="preload" href="/assets/css/reset.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="/assets/css/reset.css"></noscript>



<style>body,html{background-color:var(--body-bg-color);margin:0;padding:0;scroll-behavior:smooth;border:none}.reading-time{text-align:center}.note-date{margin-top:50px;padding-bottom:0;margin-bottom:0;font-size:smaller}.status{display:inline-block;border-radius:5px;margin-bottom:30px;margin-top:30px;font-size:.875rem;line-height:1.25rem;background-color:var(--status-bg);border:0 solid var(--status-text)}.menu ul{list-style-type:none;margin-right:20px;margin-left:20px;padding:0}ul{padding-inline-start:20px;margin-block-start:0px;margin-block-end:0px}.menu ul li{text-align:right;font-family:Inter,serif;font-size:1.2em;padding-top:10px;padding-bottom:10px}.menu{text-align:right;display:none;position:absolute;background-color:var(--navbar-bg-color);box-shadow:-10px 0 30px -15px #0000002b;right:0;position:fixed;z-index:499;top:65px;bottom:0}.menu a{text-decoration:none;color:#000}#toggle{display:none}#toggle:checked+#menu{display:flex}#navbar-desktop{background-color:var(--navbar-bg-color);position:-webkit-sticky;position:sticky;top:0;display:flex;flex-wrap:wrap;align-items:center;justify-content:space-between;padding-top:.5rem;padding-bottom:.5rem;z-index:500;border-bottom:1px solid #f0f0f0}#navbar-mobile{background-color:var(--navbar-bg-color);position:-webkit-sticky;position:sticky;top:0;display:flex;flex-wrap:wrap;flex-direction:row;align-items:center;justify-content:space-between;padding-top:1rem;padding-bottom:1rem;padding-left:5px;padding-right:5px;z-index:500;box-shadow:0 0 2px 0 #0000002b}.small-font{font-size:small}.large-font{font-size:large}.column-page{background-color:var(--projects-page-bg-color);padding-bottom:50px;display:grid;grid-gap:10px 30px;grid-template-areas:"left content right" "left footer right"}.column-page-content{background-color:var(--content-bg-color);grid-area:content;position:relative}.projects-page{background-color:var(--projects-page-bg-color);padding-bottom:50px;display:grid;grid-gap:10px 30px;grid-template-areas:"left content right" "left footer right"}.projects-page-content{background-color:var(--content-bg-color);grid-area:content;text-align:justify;position:relative}.notes-list{text-align:right;grid-area:left;list-style-position:inside;list-style:none;margin:0;padding:0}.notes-list-link{text-align:right}.notes-list-link a{text-decoration:none;color:inherit}.notes-list-link a:hover{font-weight:700;font-style:normal}.note-content .download-button{display:inline-block;padding:.25rem .5rem;border-radius:0;border:2px dashed #000;font-size:smaller}.download-button{display:inline-block;padding:.25rem .5rem;border-radius:0;border:2px dashed #000;font-size:smaller;text-decoration:none;color:inherit}.download-button:hover{background-color:var(--link-hover-color);color:#fff;transition:color .2s ease;font-weight:700;opacity:1}.menu li .resume-button{text-decoration:none;color:#fff;background-color:#000;border-radius:5px;line-height:1em;padding:8px 0 8px 10px;align-items:center;font-size:small;z-index:400}.portfolio-button{text-decoration:none;color:#fff;background-color:#000;border-radius:5px;line-height:1em;margin-right:10px;padding:4px 0 4px 10px;align-items:center;font-size:small;display:flex}.portfolio-icon{margin-left:3px;margin-right:4px}[class*=" icon-"].portfolio-icon::before,[class^=icon-].portfolio-icon::before{font-size:16px}.navbar-icon{color:#000;margin-left:5px;margin-right:5px}.note-footer{grid-area:footer;background-color:var(--footer-bg-color);border-top:2px dashed var(--gray);margin-top:20px;padding-top:.8rem;display:flex;align-items:center;justify-content:space-between}.note-tags{padding:0}.note-tags a{display:block;padding-inline-start:10px;padding-inline-end:10px;font-size:14px;line-height:30px;text-decoration:none;background-color:var(--tag-bg);border:2px solid var(--tag-text);color:var(--tag-text);border-radius:10px;transition:transform .1s}.note-tags a:before{content:"#";margin-right:.25rem}.note-tags a:hover{transform:scale(1.05)}.note-tags sup{font-size:xx-small;vertical-align:super}.note-tags li{display:inline-block;padding-right:10px;padding-bottom:5px;padding-top:5px}.tag-yellow{background-color:#ffde69;border:2px solid #594600;color:#594600}.tag{display:inline-block;padding:.25rem .75rem;margin:1rem .5rem 0 0;font-size:1rem;font-family:Inter,sans-serif;line-height:130%;border-radius:.5rem;text-decoration:none;position:relative;top:0;transition:.35s}.anchor{float:left;margin-left:-1em;padding-right:.34em;vertical-align:middle;color:#000;visibility:hidden;background:0 0}.images-row{display:flex;margin:20px -5px}.images-row picture{margin:0 5px}.images-row img{max-width:100%;height:100%;border-radius:4px}li{margin:0;padding:0;font-family:Inconsolata,monospace;text-align:justify;font-style:normal;font-size:16px;letter-spacing:.02em;line-height:1.6em}p img{max-width:100%;border-radius:4px}p img[width][height]{height:100%}p img{display:block;margin-left:auto;margin-right:auto;border-style:none;margin-bottom:20px;margin-top:20px}.note-video{display:block;margin-left:auto;margin-right:auto;margin-top:30px;margin-bottom:30px}.blob-num{border-right:1px solid #ddd}.gist-meta a{color:#3b5998!important;font-weight:700;text-decoration:none}.gist-meta a:hover{text-decoration:underline!important}.original-marker{background:linear-gradient(104deg,rgba(130,255,173,0) .9%,#82ffad 2.4%,rgba(130,255,173,.5) 5.8%,rgba(130,255,173,.1) 93%,rgba(130,255,173,.7) 96%,rgba(130,255,1732,0) 98%),linear-gradient(183deg,rgba(130,255,173,0) 0,rgba(130,255,173,.3) 7.9%,rgba(130,255,173,0) 15%);padding:.1em .4em;-webkit-box-decoration-break:clone;margin:0;border-radius:7.5px;text-shadow:-12px 12px 9.8px rgba(130,255,173,.7),21px -18.1px 7.3px #fff,-18.1px -27.3px 30px #fff}mark2{margin:0 -.4em;padding:.1em .4em;border-radius:.8em .3em;background:0 0;background-image:linear-gradient(to right,rgba(255,225,0,.1),rgba(255,225,0,.7) 4%,rgba(255,225,0,.3));-webkit-box-decoration-break:clone;box-decoration-break:clone}#profile-picture{width:50px;height:50px;border-radius:9999px}.navbar-nav>.active{color:#282828;font-weight:700}.nav-title{color:#1b1b1b;text-decoration:none;padding-top:.5rem;padding-bottom:.5rem;padding-left:.75rem;padding-right:.75rem;border-radius:.25rem}.nav-title:hover{color:#000;background:#f4f4f4}.nav-title-active{color:#1571e4}@font-face{font-family:icons;src:url('/assets/fonts/icons.woff2?7673508') format('woff2'),url('/assets/fonts/icons.woff?7673508') format('woff'),url('/assets/fonts/icons.svg?7673508#icons') format('svg');font-weight:400;font-style:normal;font-display:swap}.footer-icon{color:#bebebe}.footer-icon:hover{color:#3c3c3c}[class*=" icon-"]:before,[class^=icon-]:before{font-family:icons;font-style:normal;font-weight:400;display:inline-block;text-decoration:inherit;font-size:24px;width:1em;margin-right:.2em;text-align:center;font-variant:normal;text-transform:none;line-height:1em;margin-left:.2em;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.icon-arrow-up:before{content:'\e800'}.icon-arrow-left:before{content:'\e801'}.icon-eye:before{content:'\e802'}.icon-menu:before{content:'\f008'}.icon-twitter:before{content:'\f099'}.icon-github:before{content:'\f09b'}.icon-linkedin:before{content:'\f0e1'}@media only screen and (max-device-width:1920px){#navbar-mobile{display:none}#back-to-top-mobile{display:none}p img[width]{width:50%}}@media only screen and (max-device-width:400px){#navbar-mobile{display:flex}#navbar-desktop{display:none}#back-to-top-mobile{display:block}#back-to-top-desktop{display:none}p img[width]{width:100%}}@media (min-width:300px){.column-page,.note{grid-template-columns:auto 300px auto}}@media (min-width:576px){.column-page,.note{grid-template-columns:auto 400px auto}}@media (min-width:768px){.column-page,.note{grid-template-columns:auto 400px auto}}@media (min-width:992px){.column-page,.note{grid-template-columns:auto 600px auto}}@media (min-width:1200px){.column-page,.note{grid-template-columns:auto 600px auto}}@media (min-width:1400px){.column-page,.note{grid-template-columns:auto 600px auto}}:root{--body-bg-color:#fcfcfc;--note-bg-color:#fcfcfc;--projects-page-bg-color:#fcfcfc;--scrollbar-bg-color:rgba(0, 0, 0, 0.15);--navbar-bg-color:#fefefe;--footer-bg-color:#fcfcfc;--content-size:800px;--link-hover-color:rgb(0, 0, 0);--marker-roundness:10px;--green:130,255,173;--orange:255,218,98;--blue:79,155,255;--red:255,98,124;--yellow:255,234,71;--gray:rgba(60, 60, 60, 0.7)}body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}.px-50{padding-left:.5rem;padding-right:.5rem}.px-75{padding-left:.75rem;padding-right:.75rem}.px-150{padding-left:1.5rem;padding-right:1.5rem}.py-50{padding-top:.5rem;padding-bottom:.5rem}.py-75{padding-top:.75rem;padding-bottom:.75rem}.rounded-25{border-radius:.25rem}.c-gray{color:#282828}.bg-gray-hover:hover{background:#f4f4f4}.no-underline{text-decoration:none}.align-right{text-align:right;list-style-position:inside}::selection{background-color:#e0e0e0}.fade-in{animation:fade-in .8s cubic-bezier(.165,.84,.44,1) both}@keyframes fade-in{0%{opacity:0}100%{opacity:1}}h1,h2,h3{padding-top:40px;padding-bottom:5px}h4{padding-top:15px;padding-bottom:5px;font-size:15px}.note-entry-header h3{padding-top:0}.note-entry-content h3{padding-bottom:0}.project-entry-content h3{padding-bottom:0}.note-content h1{text-align:center}.note-content h2{margin:0}.projects-page-content h2::before{content:"#";color:#cecece;margin:0 10px 0 0}.note-content h2::before{content:"#";color:#cecece;margin:0 10px 0 0}.note-content h3{padding-top:30px}.column-page-content h2::before{content:"#";color:#cecece;margin:0 10px 0 0}.note-content p{margin-bottom:10px;padding:0;font-family:Inconsolata,monospace;text-align:justify;font-style:normal;font-size:16px;letter-spacing:.02em;line-height:1.6em}.note-content p a{text-decoration:none;border-bottom:2px dotted #000;opacity:1;color:#000}.note-content p a:hover{background-color:var(--link-hover-color);color:#fff;transition:color .2s ease;font-weight:700;opacity:1}mark.green{--marker-color:var(--green)}mark.blue{--marker-color:var(--blue)}mark.orange{--marker-color:var(--orange)}mark.red{--marker-color:var(--red)}mark.yellow{--marker-color:var(--yellow)}mark{padding:.1em 5px;margin-right:-5px;margin-left:-5px;border-radius:var(--marker-roundness);-webkit-box-decoration-break:clone;box-decoration-break:clone;background:linear-gradient(104deg,rgba(0,0,0,0) .9%,rgba(var(--marker-color),1.25) 2.4%,rgba(var(--marker-color),.5) 5.8%,rgba(var(--marker-color),.25) 93%,rgba(var(--marker-color),.7) 96%,rgba(0,0,0,0) 98%),linear-gradient(183deg,rgba(0,0,0,0) 0,rgba(var(--marker-color),.3) 7.9%,rgba(0,0,0,0) 15%)}blockquote{box-sizing:border-box;font-style:italic;color:#494949;background-color:rgba(235,236,237,.5);border-color:transparent;border-radius:3px;border-width:1px;border-style:solid;margin-top:10px;margin-bottom:10px;padding:8px 0 8px 8px}.column-page-content blockquote p{margin:0}.katex-display .katex{padding:5px 10px 5px 10px;border:2px dashed #cacaca;border-radius:5px}.projects{margin:0 auto;display:grid;grid-gap:1rem;grid-template-columns:repeat(auto-fill,minmax(200px,1fr))}.project-entry{position:relative;background:#fff;border-radius:10px;transition:transform .2s;border:1px solid #f0f0f0}.project-entry-image{border-radius:10px 10px 0 0;height:100px;object-fit:cover;width:100%}.project-entry:active{transform:scale(.95)}.project-entry-content{padding:15px}.project-entry-description{margin:8px 0;color:var(--gray);font-size:14px;line-height:1.6;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2}.project-entry-footer{color:var(--gray);font-size:12px}.project-entry-link{position:absolute;left:0;right:0;top:0;bottom:0}.note-entry-content{position:relative;margin-bottom:20px;padding:15px;background:#fff;border-radius:10px;transition:transform .2s;border:1px solid #f0f0f0}.note-entry:active{transform:scale(.95)}.note-entry-description{margin:8px 0;color:var(--gray);font-size:14px;line-height:1.6;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2}p{-webkit-hyphens:auto;-ms-hyphens:auto;-moz-hyphens:auto;hyphens:auto}.column-page-content .note-entry-description p{text-align:left}.column-page-content .note-entry-header h3{line-height:1.3em}.column-page-content p{margin-bottom:10px;font-family:Inconsolata,monospace;text-align:justify;font-style:normal;font-size:16px;letter-spacing:.02em;line-height:1.6em}.note-title{line-height:1.3em}.column-page-content p a{text-decoration:none;border-bottom:2px dotted #000;opacity:1;color:#000}.column-page-content p a:hover{background-color:var(--link-hover-color);color:#fff;transition:color .2s ease;font-weight:700;opacity:1}.note-entry-description p{font-family:Inter,serif}.note-entry-footer{color:var(--gray);font-size:12px}.note-entry-link{position:absolute;left:0;right:0;top:0;bottom:0}.bold{font-weight:700}.timeline{margin-top:20px;margin-bottom:20px}.timeline-list{position:relative;padding-left:45px;list-style:none}.timeline-event p{position:relative;top:-5px;margin:0;text-align:left}.timeline-event .year{font-size:small;padding:0;margin:0;font-weight:700;color:#6e6e6e}.timeline-event{position:relative}.timeline-event.is-not-done{padding-bottom:30px}.timeline-event.is-done{padding-bottom:15px}.timeline-event:before{display:inline-block;content:'';position:absolute;left:-37px;height:100%;width:10px}.timeline-event::after{content:'';display:inline-block;position:absolute;top:0;left:-44px;width:12px;height:12px;border:2px solid #000;border-radius:50%;background-color:#fff}.timeline-event.is-not-done::before{border-left:3px dotted #000}.timeline-event.is-done:not(:last-child)::before{border-left:3px solid #000}.timeline-event.is-done::after{font-size:10px;border:2px solid #000;background-color:#000}.home-header{display:flex;align-items:center;padding-top:20px;padding-bottom:20px}.home-header h2{padding:0;margin:0 0 0 10px;text-align:left}.home-header img{width:3.5rem;height:3.5rem;border-radius:100%;flex-grow:0;flex-shrink:0}.back-to-top-mobile{position:absolute;top:116vh;right:0;bottom:0}.back-to-top-mobile a{padding:.5rem;position:-webkit-sticky;position:sticky;top:91vh;text-decoration:none;display:inline-block;text-align:center;transition:top .4s ease 0s;color:#000;background-color:#fff;border-radius:.25rem;box-shadow:0 8px 15px rgba(0,0,0,.1)}.back-to-top-desktop{position:absolute;top:120vh;bottom:0;right:-100px}.back-to-top-desktop a{padding:.5rem;position:-webkit-sticky;position:sticky;top:91vh;text-decoration:none;display:inline-block;text-align:center;transition:top .4s ease 0s;color:#3c3c3c;background-color:#fff;border-radius:.25rem;box-shadow:0 8px 15px rgba(0,0,0,.1)}.back-to-top-desktop a:hover{top:85vh;color:#aaa}::-webkit-scrollbar{width:22px}::-webkit-scrollbar-track{background:0 0}::-webkit-scrollbar-thumb{background:var(--scrollbar-bg-color);border:5px solid var(--body-bg-color);border-radius:8px}::-webkit-scrollbar-thumb:hover{background:rgba(0,0,0,.25)}code[class*=language-],pre[class*=language-]{color:#d6deeb;font-family:Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;font-size:1em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:rgba(29,59,83,.99)}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:rgba(29,59,83,.99)}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:1.25em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{color:#fff;background:#011627;border-radius:4px}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.prolog{color:#637777;font-style:italic}.token.punctuation{color:#c792ea}.namespace{color:#b2ccd6}.token.deleted{color:rgba(239,83,80,.56);font-style:italic}.token.property,.token.symbol{color:#80cbc4}.token.keyword,.token.operator,.token.tag{color:#7fdbca}.token.boolean{color:#ff5874}.token.number{color:#f78c6c}.token.builtin,.token.char,.token.constant,.token.function{color:#82aaff}.token.doctype,.token.selector{color:#c792ea;font-style:italic}.token.attr-name,.token.inserted{color:#addb67;font-style:italic}.language-css .token.string,.style .token.string,.token.entity,.token.string,.token.url{color:#addb67}.token.atrule,.token.attr-value,.token.class-name{color:#ffcb8b}.token.important,.token.regex,.token.variable{color:#d6deeb}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}pre::-webkit-scrollbar-thumb{background:#6e6e6e;border:5px solid;border-radius:8px;border-color:#011627}pre::-webkit-scrollbar-thumb:hover{background:#969696}</style>

<!-- Request the stylesheet asynchronously. The onload attribute allows the CSS to be processed when it finishes loading. The noscript works as a fallback for browsers that don't execute JS. -->
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"></noscript>

<!-- ICONS -->
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22><text y=%2224%22 font-size=%2224%22>🖍️</text></svg>">
<link rel="preload" as="font" href="/assets/fonts/icons.woff2?7673508" type="font/woff2" crossorigin="crossorigin"/>

<!-- INLINED GOOGLE FONTS -->
<link rel="preconnect" as="font" href="https://fonts.gstatic.com">
<style>
  body,
  h1,
  h2,
  h3,
  h5 {
    font-family: 'Inter', serif;
  }
</style>
<style>
  /* latin */
  @font-face {
    font-family: 'Inter';
    font-style: normal;
    font-weight: 700;
    font-display: swap;
    src: url("https://fonts.gstatic.com/s/inter/v3/UcC73FwrK3iLTeHuS_fvQtMwCp50KnMa1ZL7.woff2") format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  }
</style>
<!-- <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">-->

<!-- GOOGLE ANALYTICS -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-137365487-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());
    gtag('config', 'UA-137365487-1');
  </script>

    </head>

    <!-- BODY -->
    <body class="fade-in">
            
<style>
    :root {
        --marker-color: var(--yellow);
    }
</style>

<!-- NAV BAR -->
<header id="navbar-desktop" class="py-75 px-150">
  <!-- <a href="/" aria-label="Back to home page."> <span class="icon-menu px-75 py-75 rounded-25 c-gray bg-gray-hover"></span></a> -->

  <a href="/" aria-label="Back to home page.">
    <img src="/assets/img/icons/letter_a.svg" style="width: 32px; height: 32px;" alt="Website icon" class="navbar-icon"></a>

  <div class="navbar-nav">

  <!--  <a href="/projects" title="My projects" aria-label="My projects." class=" nav-title">Projects</a>-->

<a href="/" aria-label="Home page." class=" nav-title">Home</a>

    <a href="/notes" aria-label="All notes." class=" nav-title">Notes</a>

    <a href="/tags" aria-label="All tags." class=" nav-title">Tags</a>

    <a href="/contact" aria-label="Contact me." class=" nav-title">Contact</a>

  </div>
</header>

<!-- https://cutcodedown.com/tutorial/mobileMenu-->
<!--https://medium.com/@heyoka/responsive-pure-css-off-canvas-hamburger-menu-aebc8d11d793-->
<header id="navbar-mobile">
  <a href="/" aria-label="Back to home page.">
    <img src="/assets/img/icons/letter_a.svg" style="width: 32px; height: 32px;" alt="Website icon" class="navbar-icon"></a>

  <div style="vertical-align: middle; display: flex; align-items: center;">
 <!--   <a class="portfolio-button" href="/projects">My work<span class="icon-eye portfolio-icon"></span></a>-->

   <label for="toggle">
      <span class="icon-menu navbar-icon"></span></label>
  

  </div>

   


</header>

  <input type="checkbox" id="toggle"/>
    <div id="menu" style="" class="menu">
      <ul>
         <!--  <li>
          <a href="/projects">Projects</a>
        </li>-->
        <li>
          <a href="/">Home</a>
        </li>
        <li>
          <a href="/notes">Notes</a>
        </li>
        <li>
          <a href="/tags">Tags</a>
        </li>
        <li>
          <a href="/contact">Contact</a>
        </li>
        <li>
          <a class="resume-button" href="/downloads/documents/resume_alexander_ameye.pdf" download rel="nofollow">Resume<span class="icon-eye portfolio-icon"></span></a>
        </li>
      </ul>
    </div>

<div class="note column-page">
    <div class="note-content column-page-content">
        <h1 class="note-title">🖍️
            5 ways to draw an outline</h1>

        
          <div class="reading-time">11-minute read</div><h2>Introduction</h2>
<p>Rendering outlines is a technique that is often used in games either for stylistic reasons or for supporting gameplay by using it for highlights and selections around an object. In this post, I will discuss 5 techniques for rendering an outline.</p>
<p>// example of outlines in games with stylistic and functional reason</p>
<h2>Rim Effects</h2>
<p>// final result image</p>
<h3>Technique</h3>
<p>One of the most basic outline effects can be achieved by using a so called fresnel effect which can be used to render an outline on the rim/edge of an object. The fresnel effect describes the reflection/transmission of light when falling onto a transparent surface. However, when using it for rendering outlines, the physical meaning of the effect is not important. The following formula is used to create the outline. It takes the dot product between the normalized normal vector <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> and the normalized view direction <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span>. Then it gets exponentiated with a power <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span>. It is important to note that this is only an approximation of the fresnel effect, but it works well for our outlines.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mo>=</mo><mi>p</mi><mi>o</mi><mi>w</mi><mo>(</mo><mo>(</mo><mn>1</mn><mi mathvariant="normal">.</mi><mn>0</mn><mo>−</mo><mi>s</mi><mi>a</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>(</mo><mi>d</mi><mi>o</mi><mi>t</mi><mo>(</mo><mi>N</mi><mo separator="true">,</mo><mi>V</mi><mo>)</mo><mo>)</mo><mo>)</mo><mo separator="true">,</mo><mi>P</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">Out = pow((1.0 - saturate(dot(N, V))), P)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit">u</span><span class="mord mathit">t</span><span class="mrel">=</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mord mathrm">.</span><span class="mord mathrm">0</span><span class="mbin">−</span><span class="mord mathit">s</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mopen">(</span><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span></span></p>
<p>Visually, the fresnel effect looks like this. You see that when we approach the grazing angle (the rim of the object), the effect gets stronger.</p>
<p><picture><source type="image/webp" srcset="fresnel-effect-300w.webp 300w, fresnel-effect-400w.webp 400w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="fresnel-effect-300w.jpeg 300w, fresnel-effect-400w.jpeg 400w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Adding the custom pass." style="width:undefined;" loading="lazy" decoding="async" src="fresnel-effect-300w.jpeg" width="400" height="286"></picture></p>
<h3>Implementation</h3>
<p>For this approach, the objects that need to have an outline get rendered using a shader that implements the fresnel effect. The shader implements the fresnel effect and allows us to set the width/power/softness/color of the outline.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token keyword">float</span> edge1 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> _OutlineWidth<span class="token punctuation">;</span><br><span class="token keyword">float</span> edge2 <span class="token operator">=</span> edge1 <span class="token operator">+</span> _OutlineSoftness<span class="token punctuation">;</span><br><span class="token keyword">float</span> fresnel <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> <span class="token function">saturate</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>normalWS<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">normalize</span><span class="token punctuation">(</span>viewWS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _OutlinePower<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token function">lerp</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">smoothstep</span><span class="token punctuation">(</span>edge1<span class="token punctuation">,</span> edge2<span class="token punctuation">,</span> fresnel<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> edge1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> _OutlineColor<span class="token punctuation">;</span></code></pre>
<p>This technique produces an outline that is always an <mark>inner line</mark> and is not visible outside of the object and so maybe shouldn't even be called an outline. Using the controls for width/power/softness/color, it is possible to create hard lines or a more soft glowy effect.</p>
<p>// image with result (hard + soft)</p>
<p>The main downside of this approach is that it works well for objects like spheres and capsules, but it breaks down for objects like cubes or more complex models that have sharp edges.</p>
<h2>Vertex Extrusion</h2>
<p>// result image</p>
<h3>Technique</h3>
<p>The second technique uses a <mark>re-rendered/duplicate</mark> version of the original object to create the outline. This duplicate object gets shown <mark>behind</mark> the original object and its vertices are extruded in order to make the object larger than the original one. The duplicate object is usually just rendered with a flat color.</p>
<h3>Extrusion direction</h3>
<p>In order to make the duplicate mesh larger, we need to change the positions of the vertices. We will be moving the vertices a certain <mark>distance</mark> along a certain <mark>direction</mark>. The first step is to pick this direction.</p>
<h4>1. Vertex position</h4>
<p>The <mark>first method</mark> to enlarge the mesh is to simply scale it up. This is done by moving each vertex position along the vertex position. This may sound kind of weird but the vertex position itself in local space, is a vector between the center of the object and the vertex position itself and so we can move the original vertex position along it. For the distance, we use a width parameter.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Move vertex along vertex position in object space.</span><br>positionOS <span class="token operator">+=</span> positionOS <span class="token operator">*</span> width<span class="token punctuation">;</span></code></pre>
<p>Doing this just kind of inflates the mesh.</p>
<p>// result image</p>
<p>For a sphere, all of the vertices have the same distance from the center and so they get moved an equal amount. However, for other objects, these distances may vary and so vertices that are distanced further away from the center of the object, will get moved more. To fix this, you can normalize the vector along which the movement occurs.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Move vertex along normalized vertex position in object space.</span><br>positionOS <span class="token operator">+=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>positionOS<span class="token punctuation">)</span> <span class="token operator">*</span> width<span class="token punctuation">;</span></code></pre>
<p>The result is an outline that is somewhat more equal-width than before since now all vertices get moved the same amount.</p>
<p>// result image</p>
<h4>2. Normal vector</h4>
<p>A <mark>second method</mark> is to move the vertices along their normal vector.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Move vertex along normal vector in object space.</span><br>positionOS <span class="token operator">+=</span> normalOS <span class="token operator">*</span> width<span class="token punctuation">;</span></code></pre>
<p>The result is a pretty nice-looking outline for objects with smooth corners such as spheres and capsules.</p>
<p>// result image</p>
<p>For objects with sharper corners such as cubes, you will get visible gaps in the outline. In general, any model with sharp angles will have these kind of artifacts.</p>
<p>// image of 'exploded' cube artifacts</p>
<h4>3. Vertex color</h4>
<p>A <mark>third method</mark> is to move the vertices along their vertex color. The logic behind this is that you can generate custom normals and store those in the vertex color channels. For example you could bake spherical (smooth) normals into vertex colors and use those for a cube mesh</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Move vertex along normal vector in object space.</span><br>positionOS <span class="token operator">+=</span> vertexColor <span class="token operator">*</span> width<span class="token punctuation">;</span></code></pre>
<p>// result image</p>
<p>This method can avoid artifacts with models that have sharp edges but the big downside is the manual setup involved.</p>
<h3>Extrusion space</h3>
<p>Once we have decided the direction along which we want to move the vertices, we need to choose in which coordinate space this should happen. During the vertex stage of our shader, the coordinates of the vertices start out being defined in object space and get transformed to clip space. This is done by applying the MVP (model/view/projection) matrix. Throughout the whole rendering pipeline, the coordinates of the vertices go through these spaces.</p>
<blockquote>
<p><strong>1.</strong> 📦 object/model/local space</p>
</blockquote>
<blockquote>
<p><strong>2.</strong> 🌍 world space</p>
</blockquote>
<blockquote>
<p><strong>3.</strong> 📷 camera/eye/view space</p>
</blockquote>
<blockquote>
<p><strong>4.</strong> ✂️ (homogeneous) clip space</p>
</blockquote>
<blockquote>
<p><strong>5.</strong> 🖥️ screen space</p>
</blockquote>
<blockquote>
<p><strong>6.</strong> 🖼️ viewport/window space</p>
</blockquote>
<p>The significance of these coordinate spaces for our outlines will be explained below. For more info, you can read my note on <a href="/notes/spaces-and-transformations" target="_blank" rel="noopener noreferrer">spaces and transformations</a>.</p>
<h4>Object space</h4>
<p>The <mark>first method</mark> is to translate the vertices in object space.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Move vertex along vertex position in object space.</span><br>IN<span class="token punctuation">.</span>positionOS<span class="token punctuation">.</span>xyz <span class="token operator">+=</span> IN<span class="token punctuation">.</span>positionOS<span class="token punctuation">.</span>xyz <span class="token operator">*</span> width<span class="token punctuation">;</span></code></pre>
<p>There are 2 big issues with doing the outline in object space. This is because when working in object space, the MVP transformations are yet to be applied. These transformations will alter the shape of the outline, distorting it as a result. The issues are as follows:</p>
<ol>
<li>
<p><mark>Scaling</mark> of the outline</p>
<p>-&gt; when going from object space to world space (applying model matrix M)</p>
</li>
<li>
<p><mark>Foreshortening</mark></p>
<p>-&gt; due to the perspective divide happening when going from clip space to screen space</p>
</li>
</ol>
<p>// image of issues</p>
<p>Another consideration is that when translating the vertices in object space, this is done in a 3D space. This means that some translations will be done directly towards or away from the camera, not contributing to the apparent-width of the outline. Instead of using object-space units, it might be better to be able to control the outline width in terms of screen-space pixels.</p>
<h4>Clip space</h4>
<p>A <mark>second method</mark> is to perform the translations of the vertices in clip space.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Transform vertex from object space to clip space.</span><br>OUT<span class="token punctuation">.</span>positionHCS <span class="token operator">=</span> <span class="token function">TransformObjectToHClip</span><span class="token punctuation">(</span>IN<span class="token punctuation">.</span>positionOS<span class="token punctuation">.</span>xyz<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Transform normal vector from object space to clip space.</span><br><span class="token keyword">float3</span> normalHCS <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float3x3</span><span class="token punctuation">)</span>UNITY_MATRIX_VP<span class="token punctuation">,</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float3x3</span><span class="token punctuation">)</span>UNITY_MATRIX_M<span class="token punctuation">,</span> IN<span class="token punctuation">.</span>normalOS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Move vertex along normal vector in clip space.</span><br>OUT<span class="token punctuation">.</span>positionHCS<span class="token punctuation">.</span>xy <span class="token operator">+=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>normalHCS<span class="token punctuation">.</span>xy<span class="token punctuation">)</span> <span class="token operator">/</span> _ScreenParams<span class="token punctuation">.</span>xy <span class="token operator">*</span> OUT<span class="token punctuation">.</span>positionHCS<span class="token punctuation">.</span>w <span class="token operator">*</span> width <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre>
<p>As a first step, the vertex position and normal vector are both transformed from object space to clip space. As a second step, the vertex gets translated along its normal vector. Since we are working in a 2D space now, only the x and y coordinates of the vertex positions get altered. The offset gets divided by the width and height of the screen to account for the aspect ratio of the screen. Then, the offset gets multiplied by the w component of the clip space vertex position. This is done because in the next stage, the clip space coordinates will be converted to screen space coordinates with a so-called perspective divide which will divide the clip space x/y/z coordinates by the clip space w coordinate. Since we want to end up with the same outline after this transformation to screen space, we pre-multiply by this clip space w coordinate so that the perspective divide will have no net effect on the outline. Finally, the offset gets multiplied by our desired outline width and a factor 2 so that a width unit 1 will correspond with exactly 1 pixel on the screen.</p>
<p><em>Phew!</em></p>
<p>I recommend reading this post on <a href="https://www.videopoetics.com/tutorials/pixel-perfect-outline-shaders-unity/#working-in-clip-space" target="_blank" rel="noopener noreferrer">creating an outline in clip space</a>. Having something explained in different ways is always useful.</p>
<h3>Masking</h3>
<p>The duplicate mesh should be rendered so that only the outline sticking out is visible. The most common solution for this is to <mark>cull the front-facing geometry</mark> of the duplicated mesh, using the backfaces of the geometry to form the outline. A depth test of <mark>less than or equal to</mark> is used to make sure the backfaces only show up where the outlines should go.</p>
<p>// image</p>
<p>Another option is to use a stencil mask to prevent the duplicate mesh from showing up in front of the original mesh. When using this stencil mask method, no culling is needed.</p>
<p>// image</p>
<h2>Blurred Buffer</h2>
<p><picture><source type="image/webp" srcset="blurred-buffer-result-300w.webp 300w, blurred-buffer-result-400w.webp 400w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="blurred-buffer-result-300w.jpeg 300w, blurred-buffer-result-400w.jpeg 400w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:undefined;" loading="lazy" decoding="async" src="blurred-buffer-result-300w.jpeg" width="400" height="262"></picture></p>
<h3>Technique</h3>
<p>An third method to render an outline is by using something that I call a <mark>blurred buffer</mark>. For this technique, the silhouette of an object gets rendered to a buffer. This silhouette buffer is then blurred which expands the silhouette which is then used to render the outline.</p>
<h3>1. Silhouette Buffer</h3>
<p>The first step of this technique is creating the silhouette buffer. For this, each object gets rendered to a texture using a shader that outputs a plain color.</p>
<div class="images-row">
<picture><source type="image/webp" srcset="silhouette-buffer-colored-300w.webp 300w, silhouette-buffer-colored-400w.webp 400w, silhouette-buffer-colored-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="silhouette-buffer-colored-300w.jpeg 300w, silhouette-buffer-colored-400w.jpeg 400w, silhouette-buffer-colored-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:undefined;" loading="lazy" decoding="async" src="silhouette-buffer-colored-300w.jpeg" width="600" height="300"></picture>
<picture><source type="image/webp" srcset="silhouette-buffer-colored-300w.webp 300w, silhouette-buffer-colored-400w.webp 400w, silhouette-buffer-colored-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="silhouette-buffer-colored-300w.jpeg 300w, silhouette-buffer-colored-400w.jpeg 400w, silhouette-buffer-colored-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:undefined;" loading="lazy" decoding="async" src="silhouette-buffer-colored-300w.jpeg" width="600" height="300"></picture>
</div>
<p>You can use the color white for all silhouettes, allowing you to choose a single color for all outlines at the end by multiplying with the desired outline color. Alternatively, you can render each object silhouette with a specific color if you want each object to have a different colored outline.</p>
<h3>2. Blur Pass</h3>
<p>The blur pass is used for expanding the silhouette buffer. This is usually done using a box blur or gaussian blur. To improve performance, the silhouette buffer can be scaled down before blurring. This is advantageous because blur passes can be expensive, having to process multiple pixels per pixel since they work by taking a (weighted) average of the pixels surrounding a given pixel.</p>
<p><picture><source type="image/webp" srcset="silhouette-buffer-downscaled-300w.webp 300w, silhouette-buffer-downscaled-400w.webp 400w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="silhouette-buffer-downscaled-300w.jpeg 300w, silhouette-buffer-downscaled-400w.jpeg 400w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:undefined;" loading="lazy" decoding="async" src="silhouette-buffer-downscaled-300w.jpeg" width="400" height="310"></picture></p>
<p>Additionally, the blur pass should be done in 2 passes. This brings down the complexity of the algorithm from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>. This can be done if the used blur algorithm is a so-called <a href="https://en.wikipedia.org/wiki/Separable_filter" target="_blank" rel="noopener noreferrer">separable filter</a> which is the case both for a box blur and a gaussian blur. When doing the blur in 2 passes, the pixels get first blurred vertically, and then the vertically-blurred buffer gets blurred horizontally resulting in the final blur.</p>
<div class="images-row">
<picture><source type="image/webp" srcset="blurred-buffer-vertical-300w.webp 300w, blurred-buffer-vertical-400w.webp 400w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="blurred-buffer-vertical-300w.jpeg 300w, blurred-buffer-vertical-400w.jpeg 400w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:undefined;" loading="lazy" decoding="async" src="blurred-buffer-vertical-300w.jpeg" width="400" height="299"></picture>
<picture><source type="image/webp" srcset="blurred-buffer-final-300w.webp 300w, blurred-buffer-final-400w.webp 400w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="blurred-buffer-final-300w.jpeg 300w, blurred-buffer-final-400w.jpeg 400w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:undefined;" loading="lazy" decoding="async" src="blurred-buffer-final-300w.jpeg" width="400" height="258"></picture>
</div>
<p>A simple seperable box blur can be implemented by taking the non-weighted average around a given pixel. For a gaussian blur, the used kernel will be a gaussian kernel so that the weighted-average will be taken.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Vertical box blur.</span><br><span class="token keyword">half4</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">int</span> samples <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> _KernelSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> samples<span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">float2</span> offset <span class="token operator">=</span> <span class="token keyword">float2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">-</span> _KernelSize<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    sum <span class="token operator">+=</span> <span class="token function">SAMPLE_TEXTURE2D</span><span class="token punctuation">(</span>_MainTex<span class="token punctuation">,</span> sampler_MainTex<span class="token punctuation">,</span> IN<span class="token punctuation">.</span>uv <span class="token operator">+</span> offset <span class="token operator">*</span> _MainTex_TexelSize<span class="token punctuation">.</span>xy<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">return</span> sum <span class="token operator">/</span> samples<span class="token punctuation">;</span><br>                <br><span class="token comment">// Horizontal box blur.</span><br><span class="token keyword">half4</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">int</span> samples <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> _KernelSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> samples<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">float2</span> offset <span class="token operator">=</span> <span class="token keyword">float2</span><span class="token punctuation">(</span>x <span class="token operator">-</span> _KernelSize<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    sum <span class="token operator">+=</span> <span class="token function">SAMPLE_TEXTURE2D</span><span class="token punctuation">(</span>_MainTex<span class="token punctuation">,</span> sampler_MainTex<span class="token punctuation">,</span> IN<span class="token punctuation">.</span>uv <span class="token operator">+</span> offset <span class="token operator">*</span> _MainTex_TexelSize<span class="token punctuation">.</span>xy<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">return</span> sum <span class="token operator">/</span> samples<span class="token punctuation">;</span></code></pre>
<p>The outline width is controlled by the _KernelSize parameter of the blur shader.</p>
<h3>3. Outline Pass</h3>
<p>After the blur pass, the blurred silhouette gets combined with the original scene to form the outline.</p>
<p><picture><source type="image/webp" srcset="blurred-buffer-outline-only-300w.webp 300w, blurred-buffer-outline-only-400w.webp 400w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="blurred-buffer-outline-only-300w.jpeg 300w, blurred-buffer-outline-only-400w.jpeg 400w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:undefined;" loading="lazy" decoding="async" src="blurred-buffer-outline-only-300w.jpeg" width="400" height="342"></picture></p>
<p>Using a blurred buffer is great for having soft or glowing outlines, but the buffer can also be stepped to render a hard outline.</p>
<h3>Masking</h3>
<p>Just like for the vertex extrusion method, a stencil mask can be used to make sure the outline only gets rendered behind the geometry.</p>
<h2>Jump Flood Algorithm</h2>
<p>// result image</p>
<h3>Technique</h3>
<h3>Implementation</h3>
<h2>Edge Detection</h2>
<p><picture><source type="image/webp" srcset="edge-detection-result-300w.webp 300w, edge-detection-result-400w.webp 400w, edge-detection-result-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="edge-detection-result-300w.jpeg 300w, edge-detection-result-400w.jpeg 400w, edge-detection-result-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:100%;" loading="lazy" decoding="async" src="edge-detection-result-300w.jpeg" width="600" height="202"></picture></p>
<h3>Technique</h3>
<p>A fifth method is to use an edge-detection pass for rendering outlines. This full-screen pass draws lines by detecting discontinuities in the scene and rendering an outline between areas that have a large enough discontinuity between them. Discontinuities can be detected between on the depth buffer value, the normal vector, the albedo color or any other data that is made available.</p>
<h3>Detection of discontinuity</h3>
<p>Detecting discontinuities is can be done by using an edge detection operator such as the <a href="https://en.wikipedia.org/wiki/Roberts_cross" target="_blank" rel="noopener noreferrer">Roberts cross operator</a>. This operator works as a differential operator by calculating the sum of the squares of the differences between diagonal pixels resulting in a cross-like pattern.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token keyword">float</span> depth0 <span class="token operator">=</span> <span class="token function">SampleSceneDepth</span><span class="token punctuation">(</span>uv0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bottom left</span><br><span class="token keyword">float</span> depth1 <span class="token operator">=</span> <span class="token function">SampleSceneDepth</span><span class="token punctuation">(</span>uv1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// top left</span><br><span class="token keyword">float</span> depth2 <span class="token operator">=</span> <span class="token function">SampleSceneDepth</span><span class="token punctuation">(</span>uv2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// top right</span><br><span class="token keyword">float</span> depth3 <span class="token operator">=</span> <span class="token function">SampleSceneDepth</span><span class="token punctuation">(</span>uv3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bottom right</span><br><br><span class="token keyword">float</span> edge <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>depth0<span class="token operator">-</span>depth2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>depth3<span class="token operator">-</span>depth1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Roberts cross is a very simple operator but can already give nice results.</p>
<h3>Sources of discontinuity</h3>
<p>A common approach is to look for discontinuities in the textures that the render pipeline generates for the scene such as the depth texture, normals texture and color texture.</p>
<div class="images-row">
<picture><source type="image/webp" srcset="camera-depth-texture-300w.webp 300w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:undefined;" loading="lazy" decoding="async" src="camera-depth-texture-300w.jpeg" width="300" height="406"></picture>
<picture><source type="image/webp" srcset="camera-normals-texture-300w.webp 300w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:undefined;" loading="lazy" decoding="async" src="camera-normals-texture-300w.jpeg" width="300" height="420"></picture>
<picture><source type="image/webp" srcset="camera-color-texture-291w.webp 291w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:undefined;" loading="lazy" decoding="async" src="camera-color-texture-291w.jpeg" width="291" height="417"></picture>
</div>
<p>During the edge-detection pass, these textures are sampled and discontinuities are detected. The resulting edge that is drawn can be caused by any discontinuity that was found in one of the 3 buffers. In the image below, edge contributions by depth/normals/color are represented by the color red/green/blue respectively.</p>
<div class="images-row">
<picture><source type="image/webp" srcset="contribution-debug-300w.webp 300w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:100%;" loading="lazy" decoding="async" src="contribution-debug-300w.jpeg" width="300" height="292"></picture>
<picture><source type="image/webp" srcset="contribution-result-300w.webp 300w, contribution-result-400w.webp 400w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="contribution-result-300w.jpeg 300w, contribution-result-400w.jpeg 400w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:100%;" loading="lazy" decoding="async" src="contribution-result-300w.jpeg" width="400" height="397"></picture>
</div>
<p>Allowing discontinuities to be detected from different sources makes for a robust outlining system. In the debug image above you can see that while some edges would be detected by all three discontinuity sources, a lot of them only get picked up from a contribution of a specific discontinuity source. Each discontinuity source can be given a different weight and different thresholds can be used for each of them, allowing you to control the visual of the outline.</p>
<h3>Custom discontinuity source</h3>
<p>It is also possible to provide the outline shader with a custom discontinuity source. This would be a render texture that you create yourself during the render process, containing custom data that you wish to use to generate outlines.</p>
<div class="images-row">
<picture><source type="image/webp" srcset="custom-buffer-source-300w.webp 300w, custom-buffer-source-400w.webp 400w, custom-buffer-source-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="custom-buffer-source-300w.jpeg 300w, custom-buffer-source-400w.jpeg 400w, custom-buffer-source-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:undefined;" loading="lazy" decoding="async" src="custom-buffer-source-300w.jpeg" width="600" height="600"></picture>
<picture><source type="image/webp" srcset="custom-buffer-result-300w.webp 300w, custom-buffer-result-400w.webp 400w, custom-buffer-result-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="custom-buffer-result-300w.jpeg 300w, custom-buffer-result-400w.jpeg 400w, custom-buffer-result-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:undefined;" loading="lazy" decoding="async" src="custom-buffer-result-300w.jpeg" width="600" height="600"></picture>
</div>
<p>For example in the scene above, the discontinuity source is generated by rendering the vertex colors of a mesh to a texture. Other techniques that come to mind are coloring faces based on their world position.</p>
<h2>Conclusion</h2>
<p>There you go, 5 ways to draw an outline. They all have their benefits, making trade-offs between performance, visual fidelity and manual setup that is required.</p>
<h2>Additional Resources</h2>
<h3>Vertex Extrusion</h3>
<p><a href="https://www.videopoetics.com/tutorials/pixel-perfect-outline-shaders-unity/#working-in-clip-space" target="_blank" rel="noopener noreferrer">https://www.videopoetics.com/tutorials/pixel-perfect-outline-shaders-unity/</a>
<a href="https://bgolus.medium.com/the-quest-for-very-wide-outlines-ba82ed442cd9" target="_blank" rel="noopener noreferrer">https://bgolus.medium.com/the-quest-for-very-wide-outlines-ba82ed442cd9</a></p>
<h3>Edge Detection</h3>
<p><a href="https://roystan.net/articles/outline-shader.html" target="_blank" rel="noopener noreferrer">https://roystan.net/articles/outline-shader.html</a></p>


        <div id="back-to-top-desktop" class="back-to-top-desktop">
            <a href="#" aria-label="Back to top of page.">
                <span class="icon-arrow-up"></span></a>
            <!-- this could link to #top and then you have <a name="top"></a> somewhere so you can link to specific spots -->
        </div>

            <div id="back-to-top-mobile" class="back-to-top-mobile">
            <a href="#" aria-label="Back to top of page.">
                <span class="icon-arrow-up"></span></a>
            <!-- this could link to #top and then you have <a name="top"></a> somewhere so you can link to specific spots -->
        </div>



         <div class="note-date"><time>July 31, 2021</time></div>
    </div>

    <footer class="note-footer">
    <ul class="note-tags"><li>
                <a style="--tag-bg: #d4f0ff; --tag-text: #04509c;" href="/tags/graphics">graphics</a>
            </li><li>
                <a style="--tag-bg: #ccffe0; --tag-text: #1b715c;" href="/tags/unity">unity</a>
            </li></ul>

    <div>
        <a href="https://twitter.com/alexanderameye" rel="noopener" target="_blank" aria-label="Alexander Ameye Twitter.">
            <span class="icon-twitter footer-icon"></span></a>
        <a href="https://www.linkedin.com/in/alexander-ameye-067a0b70/" rel="noopener" target="_blank" aria-label="Alexander Ameye LinkedIn.">
            <span class="icon-linkedin footer-icon"></span></a>
        <a href="https://github.com/alexanderameye" rel="noopener" target="_blank" aria-label="Alexander Ameye GitHub.">
            <span class="icon-github footer-icon"></span></a>
    </div>
</footer>

 
</div>

<script src="https://storage.ko-fi.com/cdn/scripts/overlay-widget.js"></script>
<script>
  kofiWidgetOverlay.draw('alexanderameye', {
    'type': 'floating-chat',
    'floating-chat.donateButton.text': 'Support me',
    'floating-chat.donateButton.background-color': '#323842',
    'floating-chat.donateButton.text-color': '#fff'
  });
</script>
    </body>
</html>